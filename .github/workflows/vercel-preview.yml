name: Vercel Preview Testing

on:
  pull_request:
    types: [opened, synchronize, reopened]

env:
  NODE_VERSION: '20'

permissions:
  contents: read
  issues: write
  pull-requests: write
  deployments: read

jobs:
  preview-smoke-tests:
    name: Smoke Tests on Vercel Preview
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for Vercel Preview Deployment
        id: vercel-deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000; // 10 seconds
            const maxAttempts = 60; // 10 minutes max

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // First, try to get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run smoke tests on preview
        run: npx playwright test --grep @smoke --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: ${{ steps.vercel-deployment.outputs.url }}
          CI: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-smoke-test-results
          path: playwright-report/
          retention-days: 7

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
            const url = '${{ steps.vercel-deployment.outputs.url }}';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Vercel Preview Deployment\n\n${status} Smoke tests **${{ job.status }}**\n\nüîó Preview URL: ${url}`
            });

  lighthouse:
    name: Lighthouse Performance Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for Vercel Preview
        id: vercel-url
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000;
            const maxAttempts = 60;

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // Get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Run Lighthouse CI
        id: lighthouse
        uses: treosh/lighthouse-ci-action@v11
        with:
          urls: |
            ${{ steps.vercel-url.outputs.url }}
          uploadArtifacts: true
          temporaryPublicStorage: true
          runs: 3

      - name: Comment Lighthouse results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let lighthouseResults = '';

            try {
              // Debug: Log directory contents
              console.log('Checking for Lighthouse results...');

              if (!fs.existsSync('.lighthouseci')) {
                throw new Error('.lighthouseci directory not found');
              }

              const files = fs.readdirSync('.lighthouseci');
              console.log('Files in .lighthouseci:', files);

              // Find manifest file
              const manifestFile = files.find(f => f.includes('manifest') || f.endsWith('.json'));
              if (!manifestFile) {
                throw new Error('No manifest file found');
              }

              const manifestPath = `.lighthouseci/${manifestFile}`;
              console.log('Reading manifest from:', manifestPath);

              const manifestContent = fs.readFileSync(manifestPath, 'utf8');
              const manifest = JSON.parse(manifestContent);

              console.log('Manifest structure:', JSON.stringify(manifest, null, 2));

              // Handle different possible manifest structures
              let results;
              if (Array.isArray(manifest)) {
                results = manifest[0];
              } else if (manifest.results) {
                results = manifest.results[0];
              } else {
                results = manifest;
              }

              // Extract scores (handle both summary and lhr formats)
              let scores;
              if (results.summary) {
                scores = results.summary;
              } else if (results.lhr && results.lhr.categories) {
                const cats = results.lhr.categories;
                scores = {
                  performance: cats.performance?.score,
                  accessibility: cats.accessibility?.score,
                  'best-practices': cats['best-practices']?.score,
                  seo: cats.seo?.score
                };
              } else {
                throw new Error('Could not find scores in manifest');
              }

              // Get report URL
              const reportUrl = results.url || results.reportUrl || 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}';

              const perfScore = Math.round((scores.performance || 0) * 100);
              const a11yScore = Math.round((scores.accessibility || 0) * 100);
              const bpScore = Math.round((scores['best-practices'] || 0) * 100);
              const seoScore = Math.round((scores.seo || 0) * 100);

              lighthouseResults = '## üèÜ Lighthouse Scores\n\n';
              lighthouseResults += '- ‚ö° Performance: ' + perfScore + '\n';
              lighthouseResults += '- ‚ôø Accessibility: ' + a11yScore + '\n';
              lighthouseResults += '- ‚úÖ Best Practices: ' + bpScore + '\n';
              lighthouseResults += '- üîç SEO: ' + seoScore + '\n\n';
              lighthouseResults += '[View Full Report](' + reportUrl + ')';

            } catch (error) {
              console.error('Error parsing Lighthouse results:', error);
              lighthouseResults = '‚ö†Ô∏è Could not parse Lighthouse results\n\n';
              lighthouseResults += 'Error: ' + error.message + '\n\n';
              lighthouseResults += 'Please check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: lighthouseResults
            });
