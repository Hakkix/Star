name: Vercel Preview Testing

on:
  pull_request:
    types: [opened, synchronize, reopened]

env:
  NODE_VERSION: '20'

permissions:
  contents: read
  issues: write
  pull-requests: write
  deployments: read

jobs:
  preview-smoke-tests:
    name: Smoke Tests on Vercel Preview
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for Vercel Preview Deployment
        id: vercel-deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000; // 10 seconds
            const maxAttempts = 60; // 10 minutes max

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // First, try to get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run smoke tests on preview
        run: npx playwright test --grep @smoke --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: ${{ steps.vercel-deployment.outputs.url }}
          CI: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-smoke-test-results
          path: playwright-report/
          retention-days: 7

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
            const url = '${{ steps.vercel-deployment.outputs.url }}';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Vercel Preview Deployment\n\n${status} Smoke tests **${{ job.status }}**\n\nüîó Preview URL: ${url}`
            });

  lighthouse:
    name: Lighthouse Performance Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for Vercel Preview
        id: vercel-url
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000;
            const maxAttempts = 60;

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // Get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Run Lighthouse CI
        id: lighthouse
        uses: treosh/lighthouse-ci-action@v11
        with:
          urls: |
            ${{ steps.vercel-url.outputs.url }}
          uploadArtifacts: true
          temporaryPublicStorage: true
          runs: 3
          configPath: './lighthouserc.js'

      - name: Debug - List files
        if: always()
        run: |
          echo "Current directory contents:"
          ls -la
          echo ""
          echo "Looking for .lighthouseci directory:"
          if [ -d ".lighthouseci" ]; then
            echo "‚úÖ .lighthouseci directory found"
            ls -la .lighthouseci/
          else
            echo "‚ùå .lighthouseci directory not found"
          fi

      - name: Comment Lighthouse results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            let lighthouseResults = '';

            try {
              console.log('Checking for Lighthouse results...');
              console.log('Current working directory:', process.cwd());

              let lhr = null;
              let reportUrl = null;

              // Method 1: Try to get results from the manifest file
              const manifestPath = path.join(process.cwd(), '.lighthouseci', 'manifest.json');
              if (fs.existsSync(manifestPath)) {
                console.log('Found manifest.json, attempting to parse...');
                const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
                if (manifest && manifest.length > 0 && manifest[0].jsonPath) {
                  const lhrPath = path.join(process.cwd(), '.lighthouseci', manifest[0].jsonPath);
                  if (fs.existsSync(lhrPath)) {
                    console.log('Reading LHR file from manifest:', lhrPath);
                    lhr = JSON.parse(fs.readFileSync(lhrPath, 'utf8'));
                  }
                }
              }

              // Method 2: Try to find LHR files directly in .lighthouseci directory
              if (!lhr) {
                const lighthouseDir = path.join(process.cwd(), '.lighthouseci');
                console.log('Looking for .lighthouseci directory:', lighthouseDir);

                if (fs.existsSync(lighthouseDir)) {
                  const files = fs.readdirSync(lighthouseDir);
                  console.log('Files in .lighthouseci:', files);

                  // Find the JSON result files (lhr-*.json format)
                  const lhrFiles = files.filter(f => f.startsWith('lhr-') && f.endsWith('.json'));
                  console.log('Found LHR files:', lhrFiles);

                  if (lhrFiles.length > 0) {
                    // Read the first LHR file (they should all be for the same URL)
                    const lhrPath = path.join(lighthouseDir, lhrFiles[0]);
                    console.log('Reading LHR file:', lhrPath);
                    lhr = JSON.parse(fs.readFileSync(lhrPath, 'utf8'));
                  }
                } else {
                  console.log('‚ö†Ô∏è  .lighthouseci directory not found');
                  console.log('Directory contents:', fs.readdirSync(process.cwd()).join(', '));
                }
              }

              // If we found results, parse them
              if (lhr && lhr.categories) {
                console.log('‚úÖ LHR file parsed successfully');

                const perfScore = Math.round((lhr.categories.performance?.score || 0) * 100);
                const a11yScore = Math.round((lhr.categories.accessibility?.score || 0) * 100);
                const bpScore = Math.round((lhr.categories['best-practices']?.score || 0) * 100);
                const seoScore = Math.round((lhr.categories.seo?.score || 0) * 100);

                // Build the results message
                lighthouseResults = '## üèÜ Lighthouse Scores\n\n';
                lighthouseResults += '- ‚ö° Performance: ' + perfScore + '\n';
                lighthouseResults += '- ‚ôø Accessibility: ' + a11yScore + '\n';
                lighthouseResults += '- ‚úÖ Best Practices: ' + bpScore + '\n';
                lighthouseResults += '- üîç SEO: ' + seoScore + '\n\n';

                // Try to get the report URL from action outputs
                const outputLinks = '${{ steps.lighthouse.outputs.links }}';
                const outputManifest = '${{ steps.lighthouse.outputs.manifest }}';

                if (outputLinks && outputLinks !== '' && !outputLinks.includes('{{')) {
                  reportUrl = outputLinks;
                } else if (outputManifest && outputManifest !== '' && !outputManifest.includes('{{')) {
                  reportUrl = outputManifest;
                } else if (lhr.finalUrl) {
                  reportUrl = lhr.finalUrl;
                }

                if (reportUrl) {
                  lighthouseResults += 'üîó [View Full Report](' + reportUrl + ')\n\n';
                }

                lighthouseResults += 'üìä [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';
              } else {
                // No results found - provide helpful message
                throw new Error('Could not find Lighthouse results. The .lighthouseci directory or results files were not created.');
              }

            } catch (error) {
              console.error('‚ùå Error parsing Lighthouse results:', error.message);
              if (error.stack) {
                console.error('Stack trace:', error.stack);
              }

              // Provide a helpful error message
              lighthouseResults = '## ‚ö†Ô∏è Lighthouse Performance Check\n\n';
              lighthouseResults += 'Could not parse Lighthouse results.\n\n';
              lighthouseResults += '**Error**: ' + error.message + '\n\n';
              lighthouseResults += 'This can happen if:\n';
              lighthouseResults += '- The Lighthouse CI step failed to run\n';
              lighthouseResults += '- The deployment URL was not accessible\n';
              lighthouseResults += '- The results were uploaded but not stored locally\n\n';
              lighthouseResults += 'üìä Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details.';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: lighthouseResults
            });
