name: Vercel Preview Testing

on:
  pull_request:
    types: [opened, synchronize, reopened]

env:
  NODE_VERSION: '20'

permissions:
  contents: read
  issues: write
  pull-requests: write
  deployments: read

jobs:
  preview-smoke-tests:
    name: Smoke Tests on Vercel Preview
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for Vercel Preview Deployment
        id: vercel-deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000; // 10 seconds
            const maxAttempts = 60; // 10 minutes max

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // First, try to get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run smoke tests on preview
        run: npx playwright test --grep @smoke --project=chromium
        env:
          PLAYWRIGHT_TEST_BASE_URL: ${{ steps.vercel-deployment.outputs.url }}
          CI: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-smoke-test-results
          path: playwright-report/
          retention-days: 7

      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
            const url = '${{ steps.vercel-deployment.outputs.url }}';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Vercel Preview Deployment\n\n${status} Smoke tests **${{ job.status }}**\n\nüîó Preview URL: ${url}`
            });

  lighthouse:
    name: Lighthouse Performance Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for Vercel Preview
        id: vercel-url
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentPollInterval = 10000;
            const maxAttempts = 60;

            console.log(`Starting deployment polling for ref: ${context.payload.pull_request.head.ref}`);

            for (let i = 0; i < maxAttempts; i++) {
              // Get all deployments without environment filter
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.ref
              });

              console.log(`Found ${allDeployments.data.length} total deployment(s) for this ref`);

              if (allDeployments.data.length > 0) {
                // Log all available environments
                const environments = [...new Set(allDeployments.data.map(d => d.environment))];
                console.log(`Available environments: ${environments.join(', ')}`);

                // Look for Preview or Production environment
                const latestDeployment = allDeployments.data.find(d =>
                  d.environment === 'Preview' ||
                  d.environment === 'Production' ||
                  d.environment.toLowerCase().includes('preview')
                ) || allDeployments.data[0];

                console.log(`Checking deployment ID ${latestDeployment.id} in environment: ${latestDeployment.environment}`);

                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: latestDeployment.id
                });

                if (statuses.data.length > 0) {
                  const latestStatus = statuses.data[0];
                  console.log(`Current deployment state: ${latestStatus.state}`);

                  if (latestStatus.description) {
                    console.log(`Status description: ${latestStatus.description}`);
                  }

                  // Check for success
                  if (latestStatus.state === 'success' && latestStatus.target_url) {
                    console.log(`‚úÖ Deployment ready: ${latestStatus.target_url}`);
                    core.setOutput('url', latestStatus.target_url);
                    return latestStatus.target_url;
                  }

                  // Check for failure
                  if (latestStatus.state === 'failure' || latestStatus.state === 'error') {
                    throw new Error(`Deployment failed with state: ${latestStatus.state}. Description: ${latestStatus.description || 'No description'}`);
                  }

                  // If in progress, show target URL if available
                  if (latestStatus.target_url) {
                    console.log(`Preview URL (pending): ${latestStatus.target_url}`);
                  }
                } else {
                  console.log('No deployment statuses found yet');
                }
              } else {
                console.log('No deployments found yet for this ref');
              }

              console.log(`‚è≥ Waiting for deployment... (attempt ${i + 1}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, deploymentPollInterval));
            }

            throw new Error(`Deployment did not complete in time after ${maxAttempts} attempts (${maxAttempts * deploymentPollInterval / 60000} minutes)`);

      - name: Run Lighthouse CI
        id: lighthouse
        uses: treosh/lighthouse-ci-action@v11
        with:
          urls: |
            ${{ steps.vercel-url.outputs.url }}
          uploadArtifacts: true
          temporaryPublicStorage: true
          runs: 3
          configPath: './lighthouserc.js'

      - name: Debug - List files
        if: always()
        run: |
          echo "Current directory contents:"
          ls -la
          echo ""
          echo "Looking for .lighthouseci directory:"
          if [ -d ".lighthouseci" ]; then
            echo "‚úÖ .lighthouseci directory found"
            ls -la .lighthouseci/
          else
            echo "‚ùå .lighthouseci directory not found"
          fi

      - name: Comment Lighthouse results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            let lighthouseResults = '';

            try {
              console.log('Checking for Lighthouse results...');
              console.log('Current working directory:', process.cwd());

              // Check for .lighthouseci directory
              const lighthouseDir = path.join(process.cwd(), '.lighthouseci');
              console.log('Looking for directory:', lighthouseDir);

              if (!fs.existsSync(lighthouseDir)) {
                console.error('Directory does not exist:', lighthouseDir);
                console.log('Directory contents:', fs.readdirSync(process.cwd()));
                throw new Error('.lighthouseci directory not found');
              }

              const files = fs.readdirSync(lighthouseDir);
              console.log('Files in .lighthouseci:', files);

              if (files.length === 0) {
                throw new Error('.lighthouseci directory is empty');
              }

              // Find the JSON result files (lhr-*.json format)
              const lhrFiles = files.filter(f => f.startsWith('lhr-') && f.endsWith('.json'));
              console.log('Found LHR files:', lhrFiles);

              if (lhrFiles.length === 0) {
                throw new Error('No Lighthouse result files found');
              }

              // Read the first LHR file (they should all be for the same URL)
              const lhrPath = path.join(lighthouseDir, lhrFiles[0]);
              console.log('Reading LHR file:', lhrPath);

              const lhrContent = fs.readFileSync(lhrPath, 'utf8');
              const lhr = JSON.parse(lhrContent);

              console.log('LHR file parsed successfully');

              // Extract scores from categories
              const categories = lhr.categories;
              if (!categories) {
                throw new Error('No categories found in Lighthouse results');
              }

              const perfScore = Math.round((categories.performance?.score || 0) * 100);
              const a11yScore = Math.round((categories.accessibility?.score || 0) * 100);
              const bpScore = Math.round((categories['best-practices']?.score || 0) * 100);
              const seoScore = Math.round((categories.seo?.score || 0) * 100);

              // Get the URL from action outputs if available
              const reportUrl = '${{ steps.lighthouse.outputs.links }}' ||
                               lhr.finalUrl ||
                               '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

              lighthouseResults = '## üèÜ Lighthouse Scores\n\n';
              lighthouseResults += '- ‚ö° Performance: ' + perfScore + '\n';
              lighthouseResults += '- ‚ôø Accessibility: ' + a11yScore + '\n';
              lighthouseResults += '- ‚úÖ Best Practices: ' + bpScore + '\n';
              lighthouseResults += '- üîç SEO: ' + seoScore + '\n\n';

              if (reportUrl && reportUrl !== '${{ steps.lighthouse.outputs.links }}') {
                lighthouseResults += 'üîó [View Full Report](' + reportUrl + ')\n\n';
              }

              lighthouseResults += 'üìä [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';

            } catch (error) {
              console.error('Error parsing Lighthouse results:', error);
              console.error('Stack trace:', error.stack);

              lighthouseResults = '‚ö†Ô∏è Could not parse Lighthouse results\n\n';
              lighthouseResults += 'Error: ' + error.message + '\n\n';
              lighthouseResults += 'Please check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: lighthouseResults
            });
